{
    "Print Statement": {
      "prefix": "pr",
      "body": [
        "print(${1:message})"
      ],
      "description": "Quick print statement"
    },
    "For Loop": {
      "prefix": "for",
      "body": [
        "for ${1:var} in ${2:iterable}:",
        "    ${3:pass}"
      ],
      "description": "Simple for loop"
    },
    "While Loop": {
      "prefix": "while",
      "body": [
        "while ${1:condition}:",
        "    ${2:pass}"
      ],
      "description": "While loop structure"
    },
    "If-Else Statement": {
      "prefix": "ifelse",
      "body": [
        "if ${1:condition}:",
        "    ${2:action}",
        "else:",
        "    ${3:else_action}"
      ],
      "description": "Basic if-else structure"
    },
    "Function Definition": {
      "prefix": "defn",
      "body": [
        "def ${1:function_name}(${2:args}):",
        "    \"\"\"${3:docstring}\"\"\"",
        "    ${4:pass}"
      ],
      "description": "Define a function template"
    },
    "Lambda Function": {
      "prefix": "lambda",
      "body": [
        "${1:lambda} ${2:x}: ${3:x + 1}"
      ],
      "description": "Lambda function for quick inline operations"
    },
    "Class Definition": {
      "prefix": "class",
      "body": [
        "class ${1:ClassName}:",
        "    def __init__(self, ${2:args}):",
        "        ${3:self.arg = args}",
        "    def ${4:method}(self):",
        "        ${5:pass}"
      ],
      "description": "Class definition template"
    },
    "List Comprehension": {
      "prefix": "listcomp",
      "body": [
        "[${1:expression} for ${2:item} in ${3:iterable} if ${4:condition}]"
      ],
      "description": "Python list comprehension"
    },
    "Dictionary Comprehension": {
      "prefix": "dictcomp",
      "body": [
        "{${1:key}: ${2:value} for ${3:item} in ${4:iterable}}"
      ],
      "description": "Dictionary comprehension"
    },
    "Try-Except Block": {
      "prefix": "tryexcept",
      "body": [
        "try:",
        "    ${1:code}",
        "except ${2:Exception} as ${3:e}:",
        "    print(${4:'Error occurred:'}, ${3:e})"
      ],
      "description": "Basic try-except error handling"
    },
    "Open File": {
      "prefix": "fileopen",
      "body": [
        "with open('${1:filename}', '${2:r}') as file:",
        "    ${3:content = file.read()}"
      ],
      "description": "Open file in read mode"
    },
    "Write to File": {
      "prefix": "filewrite",
      "body": [
        "with open('${1:filename}', 'w') as file:",
        "    file.write('${2:text}')"
      ],
      "description": "Write text to a file"
    },
    "List Initialization": {
      "prefix": "listinit",
      "body": [
        "${1:list_name} = [${2:value1}, ${3:value2}, ${4:value3}]"
      ],
      "description": "List initialization"
    },
    "Tuple Initialization": {
      "prefix": "tupleinit",
      "body": [
        "${1:tuple_name} = (${2:value1}, ${3:value2}, ${4:value3})"
      ],
      "description": "Tuple initialization"
    },
    "Set Initialization": {
      "prefix": "setinit",
      "body": [
        "${1:set_name} = {${2:value1}, ${3:value2}, ${4:value3}}"
      ],
      "description": "Set initialization"
    },
    "Dictionary Initialization": {
      "prefix": "dictinit",
      "body": [
        "${1:dict_name} = {${2:key1}: ${3:value1}, ${4:key2}: ${5:value2}}"
      ],
      "description": "Dictionary initialization"
    },
    "Range Function": {
      "prefix": "range",
      "body": [
        "for ${1:i} in range(${2:start}, ${3:end}, ${4:step}):",
        "    ${5:pass}"
      ],
      "description": "Range function in a for loop"
    },
    "String Concatenation": {
      "prefix": "concat",
      "body": [
        "${1:str1} + ${2:str2}"
      ],
      "description": "String concatenation"
    },
    "String Formatting (f-string)": {
      "prefix": "fstring",
      "body": [
        "f'${1:value}'"
      ],
      "description": "Formatted string using f-string"
    },
    "String Split": {
      "prefix": "split",
      "body": [
        "${1:string}.split('${2:delimiter}')"
      ],
      "description": "Split string into list"
    },
    "String Join": {
      "prefix": "join",
      "body": [
        "${1:delimiter}.join(${2:list})"
      ],
      "description": "Join list of strings with delimiter"
    },
    "String Replace": {
      "prefix": "replace",
      "body": [
        "${1:string}.replace('${2:old}', '${3:new}')"
      ],
      "description": "Replace substring in a string"
    },
    "String Uppercase": {
      "prefix": "upper",
      "body": [
        "${1:string}.upper()"
      ],
      "description": "Convert string to uppercase"
    },
    "String Lowercase": {
      "prefix": "lower",
      "body": [
        "${1:string}.lower()"
      ],
      "description": "Convert string to lowercase"
    },
    "List Append": {
      "prefix": "append",
      "body": [
        "${1:list}.append(${2:item})"
      ],
      "description": "Append item to a list"
    },
    "List Pop": {
      "prefix": "pop",
      "body": [
        "${1:list}.pop(${2:index})"
      ],
      "description": "Pop item from a list"
    },
    "List Sort": {
      "prefix": "sort",
      "body": [
        "${1:list}.sort()"
      ],
      "description": "Sort list in ascending order"
    },
    "List Reverse": {
      "prefix": "reverse",
      "body": [
        "${1:list}.reverse()"
      ],
      "description": "Reverse list in place"
    },
    "Dictionary Get": {
      "prefix": "dictget",
      "body": [
        "${1:dict}.get('${2:key}')"
      ],
      "description": "Get value from dictionary"
    },
    "Dictionary Keys": {
      "prefix": "dictkeys",
      "body": [
        "${1:dict}.keys()"
      ],
      "description": "Get keys of a dictionary"
    },
    "Dictionary Values": {
      "prefix": "dictvalues",
      "body": [
        "${1:dict}.values()"
      ],
      "description": "Get values of a dictionary"
    },
    "Convert to List": {
      "prefix": "tolist",
      "body": [
        "list(${1:iterable})"
      ],
      "description": "Convert iterable to list"
    },
    "Convert to Set": {
      "prefix": "toset",
      "body": [
        "set(${1:iterable})"
      ],
      "description": "Convert iterable to set"
    },
    "Convert to Tuple": {
      "prefix": "totuple",
      "body": [
        "tuple(${1:iterable})"
      ],
      "description": "Convert iterable to tuple"
    },
    "Convert to Dictionary": {
      "prefix": "todict",
      "body": [
        "dict(${1:iterable})"
      ],
      "description": "Convert iterable to dictionary"
    },
    "Find Maximum": {
      "prefix": "max",
      "body": [
        "max(${1:iterable})"
      ],
      "description": "Find maximum value in iterable"
    },
    "Find Minimum": {
      "prefix": "min",
      "body": [
        "min(${1:iterable})"
      ],
      "description": "Find minimum value in iterable"
    },
    "Sum of Elements": {
      "prefix": "sum",
      "body": [
        "sum(${1:iterable})"
      ],
      "description": "Find sum of elements in iterable"
    },
    "Average of List": {
      "prefix": "avg",
      "body": [
        "sum(${1:list}) / len(${1:list})"
      ],
      "description": "Calculate average of list"
    },
    "Enumerate List": {
      "prefix": "enumerate",
      "body": [
        "for ${1:index}, ${2:item} in enumerate(${3:list}):",
        "    ${4:pass}"
      ],
      "description": "Enumerate over a list"
    },
    "Zip Two Lists": {
      "prefix": "zip",
      "body": [
        "zip(${1:list1}, ${2:list2})"
      ],
      "description": "Zip two lists together"
    },
    "Convert String to Integer": {
      "prefix": "toint",
      "body": [
        "int(${1:string})"
      ],
      "description": "Convert string to integer"
    },
    "Convert String to Float": {
      "prefix": "tofloat",
      "body": [
        "float(${1:string})"
      ],
      "description": "Convert string to float"
    },
    "Convert Integer to String": {
      "prefix": "tostr",
      "body": [
        "str(${1:integer})"
      ],
      "description": "Convert integer to string"
    },
    "Convert Float to String": {
      "prefix": "tofloatstr",
      "body": [
        "str(${1:float})"
      ],
      "description": "Convert float to string"
    },
    "Is Instance Check": {
      "prefix": "isinstance",
      "body": [
        "isinstance(${1:value}, ${2:type})"
      ],
      "description": "Check if an object is an instance of a type"
    },
    "List Slice": {
      "prefix": "slice",
      "body": [
        "${1:list}[${2:start}:${3:end}]"
      ],
      "description": "Slice a list"
    },
    "Create Empty List": {
      "prefix": "emptylist",
      "body": [
        "${1:list_name} = []"
      ],
      "description": "Create an empty list"
    },
    "Create Empty Dictionary": {
      "prefix": "emptydict",
      "body": [
        "${1:dict_name} = {}"
      ],
      "description": "Create an empty dictionary"
    },
      "Import Libraries": {
        "prefix": "imml",
        "body": [
          "import numpy as np",
          "import pandas as pd",
          "import matplotlib.pyplot as plt",
          "import seaborn as sns",
          "from sklearn.model_selection import train_test_split",
          "from sklearn.preprocessing import StandardScaler",
          "from sklearn.linear_model import LogisticRegression",
          "from sklearn.ensemble import RandomForestClassifier",
          "from sklearn.metrics import accuracy_score, confusion_matrix"
        ],
        "description": "Import common ML libraries"
      },
      "Load Dataset": {
        "prefix": "loaddata",
        "body": [
          "data = pd.read_csv('${1:dataset.csv}')"
        ],
        "description": "Load dataset using pandas"
      },
      "Split Data": {
        "prefix": "splitdata",
        "body": [
          "X = data.drop('${1:target_column}', axis=1)",
          "y = data['${1:target_column}']",
          "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)"
        ],
        "description": "Split data into train and test sets"
      },
      "Feature Scaling": {
        "prefix": "scale",
        "body": [
          "scaler = StandardScaler()",
          "X_train_scaled = scaler.fit_transform(X_train)",
          "X_test_scaled = scaler.transform(X_test)"
        ],
        "description": "Apply feature scaling to the data"
      },
      "Train Logistic Regression": {
        "prefix": "trainlogreg",
        "body": [
          "model = LogisticRegression()",
          "model.fit(X_train_scaled, y_train)"
        ],
        "description": "Train a logistic regression model"
      },
      "Train Random Forest": {
        "prefix": "trainrf",
        "body": [
          "rf_model = RandomForestClassifier(n_estimators=100, random_state=42)",
          "rf_model.fit(X_train_scaled, y_train)"
        ],
        "description": "Train a random forest classifier"
      },
      "Model Prediction": {
        "prefix": "predictmodel",
        "body": [
          "y_pred = model.predict(X_test_scaled)"
        ],
        "description": "Make predictions using the trained model"
      },
      "Model Accuracy": {
        "prefix": "accuracy",
        "body": [
          "accuracy = accuracy_score(y_test, y_pred)",
          "print('Accuracy:', accuracy)"
        ],
        "description": "Evaluate the model's accuracy"
      },
      "Confusion Matrix": {
        "prefix": "confusionmatrix",
        "body": [
          "cm = confusion_matrix(y_test, y_pred)",
          "sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')",
          "plt.show()"
        ],
        "description": "Generate confusion matrix"
      },
      "Cross Validation": {
        "prefix": "crossval",
        "body": [
          "from sklearn.model_selection import cross_val_score",
          "cv_scores = cross_val_score(model, X, y, cv=5)",
          "print('Cross-validation scores:', cv_scores)"
        ],
        "description": "Perform cross-validation"
      },
      "Save Model": {
        "prefix": "savemodel",
        "body": [
          "import joblib",
          "joblib.dump(model, '${1:model}.pkl')"
        ],
        "description": "Save the trained model using joblib"
      },
      "Load Model": {
        "prefix": "loadmodel",
        "body": [
          "model = joblib.load('${1:model}.pkl')"
        ],
        "description": "Load a saved model"
      },
      "Feature Importance": {
        "prefix": "featimportance",
        "body": [
          "importances = rf_model.feature_importances_",
          "indices = np.argsort(importances)[::-1]",
          "plt.figure(figsize=(10, 6))",
          "plt.title('Feature Importance')",
          "plt.bar(range(X_train_scaled.shape[1]), importances[indices], align='center')",
          "plt.xticks(range(X_train_scaled.shape[1]), X_train.columns[indices], rotation=90)",
          "plt.show()"
        ],
        "description": "Plot feature importance for Random Forest model"
      },
      "ROC Curve": {
        "prefix": "roccurve",
        "body": [
          "from sklearn.metrics import roc_curve, auc",
          "fpr, tpr, thresholds = roc_curve(y_test, y_pred)",
          "roc_auc = auc(fpr, tpr)",
          "plt.figure()",
          "plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)",
          "plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')",
          "plt.xlim([0.0, 1.0])",
          "plt.ylim([0.0, 1.05])",
          "plt.xlabel('False Positive Rate')",
          "plt.ylabel('True Positive Rate')",
          "plt.title('Receiver Operating Characteristic')",
          "plt.legend(loc='lower right')",
          "plt.show()"
        ],
        "description": "Plot ROC curve"
      },
      "Grid Search": {
        "prefix": "gridsearch",
        "body": [
          "from sklearn.model_selection import GridSearchCV",
          "param_grid = {",
          "  'n_estimators': [50, 100, 200],",
          "  'max_depth': [10, 20, 30]",
          "}",
          "grid_search = GridSearchCV(estimator=rf_model, param_grid=param_grid, cv=5)",
          "grid_search.fit(X_train_scaled, y_train)",
          "print('Best parameters:', grid_search.best_params_)"
        ],
        "description": "Perform Grid Search for hyperparameter tuning"
      },
      "Save Model with Pickle": {
        "prefix": "savepickle",
        "body": [
          "import pickle",
          "with open('${1:model_name}.pkl', 'wb') as f:",
          "    pickle.dump(model, f)"
        ],
        "description": "Save model using pickle"
      },
      "Load Model with Pickle": {
        "prefix": "loadpickle",
        "body": [
          "import pickle",
          "with open('${1:model_name}.pkl', 'rb') as f:",
          "    model = pickle.load(f)"
        ],
        "description": "Load a model using pickle"
      },
      "Line Plot": {
        "prefix": "lineplot",
        "body": [
          "plt.plot(x, y, color='blue', marker='o')",
          "plt.title('Line Plot')",
          "plt.xlabel('${1:x-label}')",
          "plt.ylabel('${2:y-label}')",
          "plt.grid(True)",
          "plt.show()"
        ],
        "description": "Generate a simple line plot"
      },
      "Scatter Plot": {
        "prefix": "scatterplot",
        "body": [
          "plt.scatter(x, y, color='red')",
          "plt.title('Scatter Plot')",
          "plt.xlabel('${1:x-label}')",
          "plt.ylabel('${2:y-label}')",
          "plt.show()"
        ],
        "description": "Generate a scatter plot"
      },
      "Bar Plot": {
        "prefix": "barplot",
        "body": [
          "plt.bar(x, y, color='green')",
          "plt.title('Bar Plot')",
          "plt.xlabel('${1:x-label}')",
          "plt.ylabel('${2:y-label}')",
          "plt.show()"
        ],
        "description": "Generate a bar plot"
      },
      "Histogram": {
        "prefix": "histogram",
        "body": [
          "plt.hist(data, bins=20, color='purple')",
          "plt.title('Histogram')",
          "plt.xlabel('${1:x-label}')",
          "plt.ylabel('${2:y-label}')",
          "plt.show()"
        ],
        "description": "Generate a histogram"
      },
      "Heatmap": {
        "prefix": "heatmap",
        "body": [
          "sns.heatmap(data.corr(), annot=True, cmap='coolwarm')",
          "plt.title('Correlation Heatmap')",
          "plt.show()"
        ],
        "description": "Generate a heatmap for correlation matrix"
      },
      "Boxplot": {
        "prefix": "boxplot",
        "body": [
          "sns.boxplot(x='${1:category}', y='${2:value}', data=data)",
          "plt.title('Boxplot')",
          "plt.show()"
        ],
        "description": "Generate a boxplot"
      },
      "Pairplot": {
        "prefix": "pairplot",
        "body": [
          "sns.pairplot(data, hue='${1:category}')",
          "plt.show()"
        ],
        "description": "Generate pairplot for dataset"
      },
      "Violin Plot": {
        "prefix": "violinplot",
        "body": [
          "sns.violinplot(x='${1:category}', y='${2:value}', data=data)",
          "plt.title('Violin Plot')",
          "plt.show()"
        ],
        "description": "Generate a violin plot"
      },
    

      "Adding Conv1D Layer": {
        "prefix": "conv1d",
        "body": [
          "model.add(Conv1D(32, 3, activation='relu'))"
        ],
        "description": "Adding Conv1D layer."
      },
      "Adding Conv2D Layer": {
        "prefix": "conv2d",
        "body": [
          "model.add(Conv2D(64, (3,3), activation='relu'))"
        ],
        "description": "Adding Conv2D layer."
      },
      "Adding Dense Layer": {
        "prefix": "dense",
        "body": [
          "model.add(Dense(128, activation='relu'))"
        ],
        "description": "Adding Dense layer."
      },
      "Adding Dropout Layer": {
        "prefix": "dropout",
        "body": [
          "model.add(Dropout(0.5))"
        ],
        "description": "Adding Dropout layer."
      },
      "Adding MaxPooling1D Layer": {
        "prefix": "maxpool1d",
        "body": [
          "model.add(MaxPooling1D(pool_size=2))"
        ],
        "description": "Adding MaxPooling1D layer."
      },
      "Adding MaxPooling2D Layer": {
        "prefix": "maxpool2d",
        "body": [
          "model.add(MaxPooling2D(pool_size=(2,2)))"
        ],
        "description": "Adding MaxPooling2D layer."
      },
      "Adding LSTM Layer": {
        "prefix": "lstm",
        "body": [
          "model.add(LSTM(64, return_sequences=True))"
        ],
        "description": "Adding LSTM layer."
      },
      "Adding ReLU Activation": {
        "prefix": "relu",
        "body": [
          "model.add(Activation('relu'))"
        ],
        "description": "Adding ReLU activation."
      },
      "Adding Sigmoid Activation": {
        "prefix": "sigmoid",
        "body": [
          "model.add(Activation('sigmoid'))"
        ],
        "description": "Adding Sigmoid activation."
      },
      "Adding Softmax Activation": {
        "prefix": "softmax",
        "body": [
          "model.add(Activation('softmax'))"
        ],
        "description": "Adding Softmax activation."
      },
        "Linear Regression": {
          "prefix": "linearreg",
          "body": [
            "model = LinearRegression()"
          ],
          "description": "Initializing Linear Regression model."
        },
        "Logistic Regression": {
          "prefix": "logreg",
          "body": [
            "model = LogisticRegression()"
          ],
          "description": "Initializing Logistic Regression model."
        },
        "Decision Tree Classifier": {
          "prefix": "dtree",
          "body": [
            "model = DecisionTreeClassifier()"
          ],
          "description": "Initializing Decision Tree Classifier model."
        },
        "Random Forest Classifier": {
          "prefix": "rf",
          "body": [
            "model = RandomForestClassifier(n_estimators=100)"
          ],
          "description": "Initializing Random Forest Classifier model."
        },
        "K-Nearest Neighbors": {
          "prefix": "knn",
          "body": [
            "model = KNeighborsClassifier(n_neighbors=5)"
          ],
          "description": "Initializing K-Nearest Neighbors classifier."
        },
        "Support Vector Classifier": {
          "prefix": "svc",
          "body": [
            "model = SVC(kernel='linear')"
          ],
          "description": "Initializing Support Vector Classifier."
        },
        "Gradient Boosting Classifier": {
          "prefix": "gbc",
          "body": [
            "model = GradientBoostingClassifier(n_estimators=100)"
          ],
          "description": "Initializing Gradient Boosting Classifier model."
        },
        "Naive Bayes Classifier": {
          "prefix": "nb",
          "body": [
            "model = GaussianNB()"
          ],
          "description": "Initializing Naive Bayes Classifier."
        },
        "KMeans Clustering": {
          "prefix": "kmeans",
          "body": [
            "model = KMeans(n_clusters=3)"
          ],
          "description": "Initializing KMeans Clustering model."
        },
        "PCA (Principal Component Analysis)": {
          "prefix": "pca",
          "body": [
            "model = PCA(n_components=2)"
          ],
          "description": "Initializing PCA for dimensionality reduction."
        },
        "StandardScaler": {
          "prefix": "scaler",
          "body": [
            "scaler = StandardScaler()"
          ],
          "description": "Initializing StandardScaler for data normalization."
        },
        "MinMaxScaler": {
          "prefix": "minmaxscaler",
          "body": [
            "scaler = MinMaxScaler()"
          ],
          "description": "Initializing MinMaxScaler for data scaling."
        },
        "GridSearchCV": {
          "prefix": "gridsearch",
          "body": [
            "grid_search = GridSearchCV(model, param_grid, cv=5)"
          ],
          "description": "Setting up GridSearchCV for hyperparameter tuning."
        },
        "Cross-Validation": {
          "prefix": "crossval",
          "body": [
            "scores = cross_val_score(model, X, y, cv=5)"
          ],
          "description": "Performing cross-validation for model evaluation."
        },

          "Read Image": {
            "prefix": "readimg",
            "body": [
              "img = cv2.imread('image.jpg')"
            ],
            "description": "Reading an image from a file."
          },
          "Display Image": {
            "prefix": "showimg",
            "body": [
              "cv2.imshow('Image', img)"
            ],
            "description": "Displaying an image in a window."
          },
          "Save Image": {
            "prefix": "saveimg",
            "body": [
              "cv2.imwrite('output.jpg', img)"
            ],
            "description": "Saving an image to a file."
          },
          "Convert to Grayscale": {
            "prefix": "gray",
            "body": [
              "gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)"
            ],
            "description": "Converting an image to grayscale."
          },
          "Resize Image": {
            "prefix": "resize",
            "body": [
              "resized = cv2.resize(img, (width, height))"
            ],
            "description": "Resizing an image to specific dimensions."
          },
          "Edge Detection (Canny)": {
            "prefix": "canny",
            "body": [
              "edges = cv2.Canny(img, 100, 200)"
            ],
            "description": "Detecting edges in an image using Canny edge detector."
          },
          "Blur Image": {
            "prefix": "blur",
            "body": [
              "blurred = cv2.GaussianBlur(img, (5, 5), 0)"
            ],
            "description": "Blurring an image using Gaussian Blur."
          },
          "Thresholding": {
            "prefix": "thresh",
            "body": [
              "ret, thresh_img = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)"
            ],
            "description": "Applying a binary threshold to an image."
          },
          "Find Contours": {
            "prefix": "contours",
            "body": [
              "contours, hierarchy = cv2.findContours(thresh_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)"
            ],
            "description": "Finding contours in a binary image."
          },
          "Draw Contours": {
            "prefix": "drawcontours",
            "body": [
              "cv2.drawContours(img, contours, -1, (0, 255, 0), 3)"
            ],
            "description": "Drawing contours on an image."
          },
          "Add Text to Image": {
            "prefix": "addtext",
            "body": [
              "cv2.putText(img, 'Hello, OpenCV!', (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2)"
            ],
            "description": "Adding text to an image."
          },
          "Detect Faces (Haar Cascade)": {
            "prefix": "detectfaces",
            "body": [
              "faces = face_cascade.detectMultiScale(gray, 1.1, 4)"
            ],
            "description": "Detecting faces in an image using Haar Cascade classifier."
          },
          "Draw Rectangle on Image": {
            "prefix": "drawrect",
            "body": [
              "cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)"
            ],
            "description": "Drawing a rectangle around detected objects."
          },
          "Video Capture": {
            "prefix": "videocapture",
            "body": [
              "cap = cv2.VideoCapture(0)"
            ],
            "description": "Capturing video from a webcam."
          },
          "Read Frame from Video": {
            "prefix": "readframe",
            "body": [
              "ret, frame = cap.read()"
            ],
            "description": "Reading a frame from the video feed."
          },
          "Release Video Capture": {
            "prefix": "releasecap",
            "body": [
              "cap.release()"
            ],
            "description": "Releasing the video capture object."
          },
          "Apply Mask": {
            "prefix": "applymask",
            "body": [
              "mask = cv2.inRange(image, low_bound, upper_bound )"
            ],
            "description": "Applying Mask to the image."
          },
          "Add Low Bound color": {
            "prefix": "lowbound",
            "body": [
              "low_brown = np.array([30,100,20])"
            ],
            "description": "Adding Low Bound Value to Image."
          },
          "Add upper Bound Color": {
            "prefix": "uppbound",
            "body": [
              "upper_brown = np.array([0,255,255])"
            ],
            "description": "Adding Upper Bound Value to Image."
          },
          "Add WaitKey": {
            "prefix": "waitkey",
            "body": [
              "cv2.waitKey(0)",
              "cv2.destroyAllWindows()"
            ],
            "description": "Add Waitkey and DestroyAllWindows."
          },
          "Image Conversion to HSL": {
            "prefix": "tohsl",
            "body": [
              "hsl_image = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)"
            ],
            "description": "Convert BGR image to hsl"
          },
          "Bitwise_and": {
            "prefix": "bitand",
            "body": [
              "image = cv2.bitwise_and(img, img, mask=mask)"
            ],
            "description": "Appling Bitwise_and ... mask to image."
          },
          "Apply threshold": {
            "prefix": "threshold",
            "body": [
              "_, thresh = cv2.threshold(gray_image, 127, 255, cv2.THRESH_BINARY)"
            ],
            "description": "Appling threshold."
          },
          "Find contours": {
            "prefix": "findcontours",
            "body": [
              "contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)"
            ],
            "description": "Find contours."
          },
          "Draw contours": {
            "prefix": "drawcontours",
            "body": [
              "cv2.drawContours(image, contours, -1, (0, 255, 0), 3)  # Green color, thickness 3"
            ],
            "description": "Draw contours."
          }

      }
      

      

